{"aws-ec2-tf-cf":{"title":"Deploying EC2 with... everything.","links":[],"tags":["aws","cloud","VMs","EC2","CloudFront","Terraform","OpenTofu","IaC","CDK"],"content":"Let’s get straight to business.\nWhat do we want to do?\nDeploy an AWS EC2 instance in a fantastically diverse collection of ways. Not including clicking through things in a web UI (that’s cool but too slow and too easy, thus very boring) nor especially pulling an untrustworthy LLM-generated YAML or Bash script from Amazon Q itself (or loose sequence of 3 commands, to be more precise).\nWhich download we sure did!\nSo, now, let’s break that nightmare down.\n\n\n                  \n                  The LLM (Ludicrous Laziness Methodology) Zone \n                  \n                \n\n\n\n                  \n                  Note \n                  \n                \n\nObviously, sensitive information about actual things I’m deploying and my IP address have been redacted. Not that I’m worried, anyways - my ISP locked me behind CG-NAT with no IPv6, after all *ugly sobbing*.\n\n\nBefore we begin, let’s make one thing clear - I already have set up a VPC, a SSH keyset and a security group. Then I went to create a very specific kind of EC2 instance. AWS gave me two options for exporting my EC2 params: an “AI generated YAML”, or a sequence of long aws commands (probably also with a neural network shoved in there somewhere for no practical reason whatsoever):\nResources:\n EC2SecurityGroup:\n   Type: AWS::EC2::SecurityGroup\n   Properties:\n     GroupName: launch-wizard-1\n     GroupDescription: launch-wizard-1 created 2020-08-28T00:57:57.123Z\n     VpcId: vpc-0e2cd7c927ac9484e\n     SecurityGroupIngress:\n       - IpProtocol: tcp\n         FromPort: 22\n         ToPort: 22\n         CidrIp: 80.0.81.35/32\n \n EC2Instance:\n   Type: AWS::EC2::Instance\n   Properties:\n     ImageId: ami-07a4c6232c4e5a0ec\n     InstanceType: t4g.nano\n     BlockDeviceMappings:\n       - DeviceName: /dev/xvda\n         Ebs:\n           Encrypted: false\n           DeleteOnTermination: true\n           Iops: 3000\n           SnapshotId: snap-0f815581f5eda1e29\n           VolumeSize: 8\n           VolumeType: gp3\n           Throughput: 125\n     NetworkInterfaces:\n       - AssociatePublicIpAddress: true\n         DeviceIndex: 0\n         GroupSet: \n           - !Ref EC2SecurityGroup\n     CreditSpecification:\n       CPUCredits: unlimited\n     Tags:\n       - Key: Name\n         Value: My Badass Server\n       - Key: Codename  \n         Value: my-badass-serevr\n       - Key: Type\n         Value: BastionServer\n     MetadataOptions:\n       HttpEndpoint: enabled\n       HttpPutResponseHopLimit: 2\n       HttpTokens: required\n     PrivateDnsNameOptions:\n       HostnameType: ip-name\n       EnableResourceNameDnsARecord: true\n       EnableResourceNameDnsAAAARecord: false\nAnd the corresponding Bash hellcommand sequence:\n#!/usr/bin/bash\naws ec2 create-security-group --group-name &quot;launch-wizard-1&quot; --description &quot;launch-wizard-1 created 2020-08-28T00:57:57.123Z&quot; --vpc-id &quot;vpc-0e2cd7c927ac9484e&quot; \n \naws ec2 authorize-security-group-ingress --group-id &quot;sg-preview-1&quot; --ip-permissions &#039;{&quot;IpProtocol&quot;:&quot;tcp&quot;,&quot;FromPort&quot;:22,&quot;ToPort&quot;:22,&quot;IpRanges&quot;:[{&quot;CidrIp&quot;:&quot;80.0.81.35/32&quot;}]}&#039; \n \naws ec2 run-instances --image-id &quot;ami-07a4c6232c4e5a0ec&quot; --instance-type &quot;t4g.nano&quot; --block-device-mappings &#039;{&quot;DeviceName&quot;:&quot;/dev/xvda&quot;,&quot;Ebs&quot;:{&quot;Encrypted&quot;:false,&quot;DeleteOnTermination&quot;:true,&quot;Iops&quot;:3000,&quot;SnapshotId&quot;:&quot;snap-0f815581f5eda1e29&quot;,&quot;VolumeSize&quot;:8,&quot;VolumeType&quot;:&quot;gp3&quot;,&quot;Throughput&quot;:125}}&#039; --network-interfaces &#039;{&quot;AssociatePublicIpAddress&quot;:true,&quot;DeviceIndex&quot;:0,&quot;Groups&quot;:[&quot;sg-preview-1&quot;]}&#039; --credit-specification &#039;{&quot;CpuCredits&quot;:&quot;unlimited&quot;}&#039; --tag-specifications &#039;{&quot;ResourceType&quot;:&quot;instance&quot;,&quot;Tags&quot;:[{&quot;Key&quot;:&quot;Name&quot;,&quot;Value&quot;:&quot;My Badass Server&quot;},{&quot;Key&quot;:&quot;Codename&quot;,&quot;Value&quot;:&quot;my-badass-server&quot;},{&quot;Key&quot;:&quot;Type&quot;,&quot;Value&quot;:&quot;BastionServer&quot;}]}&#039; --metadata-options &#039;{&quot;HttpEndpoint&quot;:&quot;enabled&quot;,&quot;HttpPutResponseHopLimit&quot;:2,&quot;HttpTokens&quot;:&quot;required&quot;}&#039; --private-dns-name-options &#039;{&quot;HostnameType&quot;:&quot;ip-name&quot;,&quot;EnableResourceNameDnsARecord&quot;:true,&quot;EnableResourceNameDnsAAAARecord&quot;:false}&#039; --count &quot;1&quot; \nHellish indeed. Surely I can do it better just by reading a bit of documentation, right?\n\n\nWhat?\nI like the feeling of knowing what I’m doing, so let’s dive into some prerequisites.\nWhat can we do?\nTerraform\nOpenTofu\nCloudFront"},"curl-cheatsheet":{"title":"cURL cheatsheet","links":[],"tags":["curl","networking","term"],"content":"cURL cheatsheet\nUse a custom loopback interface (e.g. 127.1.2.3):\ncurl --interface 127.1.2.3 -v http://127.57.57.57:8057/\n\nIndex of helpful links\nEverything curl"},"docker":{"title":"Docker basics","links":[],"tags":["Docker","Dockerfile","containers","term","Go"],"content":"Docker\nDocker Engine\nIt runs the whole thing.\nDocker Build\nBuild images from Dockerfiles. In terms of command line toys, there’s docker build and docker buildx build which is like build on rails.\nDocker Buildx though is the client interface for building &amp; managing images, whereas Docker BuildKit is the server that does the heavy lifting including execution.\nBuilx’s build request to BuildKit includes the Dockerfile, build args and export and/or caching opts.\nExample Dockerfile\nFrom github.com/cloudnativedevops/demo.git.\nAnyways, here’s a very plain and simple Go HTTP server that runs on 127.0.0.1:8888:\npackage main\n \nimport (\n\t&quot;fmt&quot;\n\t&quot;log&quot;\n\t&quot;net/http&quot;\n)\n \nfunc handler(w http.ResponseWriter, r *http.Request) {\n\tfmt.Fprintln(w, &quot;Hello, 世界&quot;)\n}\n \nfunc main() {\n\thttp.HandleFunc(&quot;/&quot;, handler)\n\tfmt.Println(&quot;Running demo app. Press Ctrl+C to exit...&quot;)\n\tlog.Fatal(http.ListenAndServe(&quot;:8888&quot;, nil))\n}\nNow here’s the Dockerfile\nFROM golang:1.17-alpine AS build\n \nWORKDIR /src/\nCOPY main.go go.* /src/\nRUN CGO_ENABLED=0 go build -o /bin/demo\n \nFROM scratch\nCOPY --from=build /bin/demo /bin/demo\nENTRYPOINT [&quot;/bin/demo&quot;]\nThen you run one of those1 to build and run at 127.0.0.1:9999:\ndocker image build -t myhello .\ndocker container run -p 9999:8888 myhello\n\n\n                  \n                  Caution \n                  \n                \n\nThe port syntax for docker run is HOST_PORT:CONTAINER_PORT, so to access the container and receive the pretty “Hello, 世界” you refer to your host’s address with the first port you provided.\ncurl -v 127.0.0.1:9999\n\n\nInspect your image &amp; container (prints a JSON to stdout):\ndocker image inspect myhello\ndocker inspect myhello\ndocker container inspect c7112281a566\ndocker inspect c7112281a566\nAlso check if it’s running:\ndocker ps\ndocker container ls\n\n\n                  \n                  Container names \n                  \n                \n\nWhen you build an image, by default it just gets a hexadecimal ID, which you can use to refer to it later (for example, to run it). These IDs aren’t particularly memorable or easy to type, so Docker allows you to give the image a human-readable name, using the -t switch to docker image build. In the previous example you named the image myhello, so you should be able to use that name to run the image now.\n(Credit: writers of book from parent chapter’s repository)\n\n\nDocker Compose\nDocker, but on rails (featuring YAML from DevOps May Cry).\nFootnotes\n\n\nOf course, appending sudo to both commands in the case I’m still a silly GoobSec shellhead that doesn’t wanna create a Docker group. ↩\n\n\n"},"dockerfiles":{"title":"Dockerfile structure","links":["docker"],"tags":["Dockerfile","Docker","containers","term"],"content":"Dockerfiles\nFor little extras, also read up Docker basics"},"github":{"title":"GitHub","links":[],"tags":["GitHub","Git","repositories","term"],"content":"GitHub CLI reference\nGitHub web\n\n\n                  \n                  Remote repo editing \n                  \n                \n\nOpen a repository in browser, then click on a file and press the &lt;/&gt; key to open the github.dev VS Code browser editor!\n\n"},"grafana":{"title":"Grafana","links":["prometheus"],"tags":["sre","monitoring","grafana"],"content":"Grafana\nGrafana creating monitoring dashboards based on data from endpoints provided to it. It’s like a “frontend” for monitoring data scraper tools such as Prometheus, DataDog, CloudWatch and so on."},"index":{"title":"Milky Quartz on the catnet","links":[],"tags":[],"content":"Welcome to milky-quartz.netcatcat.net ‼️\nMilky Quartz! On the cat net catnet, on the net!\nThis subdomain is a big garden for all my notes surroundings topics such as:\n\nIT, CS, SWE and computing in general.\nProgramming.\nSystem operation and administration.\nDevOps!\nDevSecOps.\nDev…SomethingOps?\nSite Reliability Engineering\nSecurity\nmoar software mlemgineering…\nconputer\nWhatever floats my fancy and is vaguely related to the machine colloquially known as the “conputer”.\n"},"kubernetes-theory":{"title":"Kubernetes theory","links":["docker","minikube"],"tags":["K8s","Minikube","containers","orchestrators","term"],"content":"Kubernetes\nFor more low-level practical stuff, go to docs on Docker and K8s basics.\nFor what reason?\n[]"},"minikube":{"title":"Minikube & K8s basics","links":["docker"],"tags":["K8s","Minikube","containers","orchestrators","term"],"content":"Minikube\nA lot of starter stuff here follows from starter Go+Docker stuff at Docker basics.\nDeploying a Go helowoorld on Minikube\nFirst off, ensure you have Docker installed and Docker group set up. It errors in “no docker group” silly-mode and refuses to get sudo’d (good).\nminikube start\nkubectl run demo --image=cloudnatived/demo:hello --port=9999 --labels app=demo\nkubectl port-forward pods/demo 9999:8888\nkubectl get pods --selector app=demo\n\nThe error above also portrays how to deal with some silly little name errors - just read."},"powerstates":{"title":"Device power states","links":[],"tags":["hardware","linux"],"content":"Notes on device power states\nHibernation\nHibernation typically means the entire image of RAM memory is saved to the disk (whether SSD or HDD) and then the laptop is quote-on-quotes shut down.\nSome people claim that hibernation is not the best on Linux-based systems and for SSDs, but it really depends on the drive and distro. A healthy SSD with about 16-32GB or less of memory shouldn’t suffer too much from hibernation. Hibernation issues on Linux are also rare (myself I’ve not run into any)."},"prometheus":{"title":"Prometheus","links":["grafana"],"tags":["sre","monitoring","prometheus"],"content":"Prometheus\nPrometheus is a tool for collecting data for monitoring purposes. Basically it’s one of the “backend options” for monitoring visualization tools such as Grafana.\nTime-series data\nA concept fundamental to data collected by Prometheus. It’s as if there was a collection of same-type ordered pairs of some metric m and measured time t; “time measured” typically refers to either absolute time or time recorded in relation to Prometheus or its data source being started."},"sre-principles":{"title":"SRE principles","links":["prometheus"],"tags":["sre","monitoring"],"content":"SRE principles\nMonitoring\nConcepts from João Pereira’s 52 weeks of SRE (W2)\nBlack-box and white-box\nA name familiar from testing concepts; we can also categorize monitoring into these two:\n\n\n                  \n                  White-box monitoring \n                  \n                \n\nExamines system internals and detailed metrics.\nProvides insights into system behaviour and performance.\n\n\n                  \n                  Example\n                  \n                \n\n\nMemory usage and garbage collection metrics.\nDatabase query performance.\nInternal queue lenghts (e.g. monitoring a Kafka consumer’s offset lag).\nCache hit rates.\nApplication-specific metrics.\n\n\n\n\n\n\n\n                  \n                  Black-box monitoring \n                  \n                \n\n\nTest system behaviour from the outside, like how an end user would experience it.\nFocuses on system outputs and external behaviours.\n\n\n\n                  \n                  Examples \n                  \n                \n\n\nHTTP endpoint availability checks (can I reach this endpoint?).\nAPI response time measurements (is this request taking too long?).\nEnd-to-end transaction tests (did this operation fulfill all of its requirements?).\n\n\n\n\n\nAlerts\nAn alert’s rule defines the conditions that trigger the alert. Typically an alert also has severity attached to it.\nOne of the best practices for setting up alerts is ensuring that all alerts are actionable:\n\nEvery alert should require human intervention and have a clear resolution path. If an alert is triggered but there’s nothing an engineer can do to resolve it, then it shouldn’t be an alert.\n\nMake sure rules are not too permissive nor aggressive to avoid alarm fatigue.\nAnother one is alerting symptoms rather than causes, e.g.:\n\n\n                  \n                  Recommended examples \n                  \n                \n\n\nAPI success rate below 99.9%\nPayment processing latency &gt; 10s\nError rate exceeded 5% in the last 5 mins\n\n\n\n\n\n                  \n                  Not recommended examples \n                  \n                \n\n\nHigh CPU usage on an API server\nNetwork packets received have increased\nLow disk space on server\n\n\n\nThe handling of situations from not recommended examples can often be automated with auto-scaling or failover mechanisms (if truly necessary).\nDashboard strategies\n\n\n                  \n                  USE method \n                  \n                \n\nFor monitoring infrastructure; best used for building dashboards that track hardware resources in infrastructure, such as CPU, memory, and network devices. It tells you how happy your machines are.\n\nUtilization: Percentage time the resource is busy (e.g.: CPU usage).\nSaturation: Amount of work a resource has to do (e.g.: queue length).\nErrors: Count of error events.\n\n\n\n\n\n                  \n                  RED method \n                  \n                \n\nFor monitoring user experience; most applicable to building dashboards for services, especially a microservices environment. A well-designed RED dashboard is a proxy for user experience, telling you how happy your customers are.\n\nRate: Requests per second\nErrors: Number of failing requests\nDuration: Request latency distribution\n\n\n\n\n\n                  \n                  The Four Golden Signals \n                  \n                \n\nAccording to the Google SRE handbook, if you can only measure four metrics of your user-facing system, focus on these four.\n\nLatency: Time to serve requests\nTraffic: System demand\nErrors: Failed request rate\nSaturation: System fullness\n\n\n\nTypes of dashboards, in short:\n\nOverview dashboards (general system health checks, rapid anomaly detection).\nService-specific dashboards (detailed data for specific services and their internals).\nBusiness metric dashboards (for non-technical stakeholders and business-relevant data).\n\nDashboard best practices\n\nLine-graphs (time-series data)\n\nIdeal for latency, request volumes &amp; error rates\nShows variations over time\nTrend analysis\n\n\nGauges (utilization metircs)\n\nIdeal for CPU, memory, Service Level Objectives\nShows current values within defined ranges\nQuick visual reference for usage and limits\n\n\nTables (detailed breakdowns)\n\nIdeal for complex reports &amp; database queries\nMultiple dataset visualization\nDetailed analytical view\n\n\nHeat-maps (distribution)\n\nIdeal for pattern identification over time\nValue distribution visualization\nTemporal pattern analysis\n\n\n"},"unix-permissions":{"title":"Unix permissions","links":[],"tags":["unix","linux","permissions","chmod","term"],"content":"Unix permissions with chmod\n\nUseful examples:\nMake it executable:\nchmod +x ./run.sh\nRoot only file access:\nchmod 000 ./.creds\nRead-only exclusively for file owner:\nchmod 400 ./special-toy"},"vim-cheatsheet":{"title":"Vim cheatsheet","links":[],"tags":["vim","neovim","term"],"content":"Vi/Vim/Neovim(/Nano) Cheatsheet\nEmergency FAQ zone:\nQ :: “Oh man aw mane, we  are in som troble”\nA :: &lt;ESC&gt;+qa!+&lt;ENTER&gt;\nQ :: “Aaaa, why cannot I autocomplete file selections in my nooby Neovim setup!?”\nA :: &lt;CTRL&gt;+&lt;y&gt;\nGeneral cheatsheet (Vi family)\nGlobal substitution :: &lt;ESC&gt;+:%s/findand/replacewith1\nYank/etc into clipboard :: &lt;SHIFT&gt;+&lt;&#039;&gt;+&lt;=&gt;+&lt;y&gt; / &lt;&quot;&gt;+&lt;=&gt;+&lt;y&gt;\nPaste/etc from clipboard :: &lt;SHIFT&gt;+&lt;&#039;&gt;+&lt;=&gt;+&lt;p&gt; / &lt;&quot;&gt;+&lt;=&gt;+&lt;p&gt;\nDelete inside two HTML/XML tags :: dit, &lt;d&gt;+&lt;i&gt;+&lt;t&gt;\ne.g.: &lt;p id=&quot;catnet&quot;&gt;purge me&lt;/p&gt; → &lt;p id=&quot;catnet&quot;&gt;&lt;/p&gt;\nGo to first line :: &lt;g&gt;+&lt;g&gt;\nGo to beginning of current line :: &lt;0&gt;\nGo to beginning of current line :: &lt;$&gt; / &lt;SHIFT&gt;+&lt;4&gt;\nAppend arbitrary identical characters in an arbitrary vertical line:\n&lt;CTRL&gt;+&lt;v&gt; → &lt;j&gt; or &lt;k&gt; as much as needed → &lt;I&gt; / &lt;SHIFT&gt;+&lt;i&gt; → type your arbitrary character collection! → &lt;ESC&gt;\n\n\n                  \n                  Example \n                  \n                \n\nBefore edit:\nThe key sequence:\n \n`0&lt;Ctrl&gt;v1jI&gt; &lt;Esc&gt;`\nThe key sequence:\n0&lt;Ctrl&gt;v2jI&gt; &lt;Esc&gt;\nAfter edit:\n&gt; The key sequence:\n&gt; \n&gt; `0&lt;Ctrl&gt;v1jI&gt; &lt;Esc&gt;`\n\n\nFootnotes\n\n\nAppend /g if global substitution doesn’t work. ↩\n\n\n"}}